## ITERATE ME

`control flow``list``range``enumerate``reversed``int``sum`

### Умова

Реалізуйте функції:

* `get_squares` - повертає квадрат значень. Використовуйте `**` для зведення в ступінь
* `get_indices_from_one` - повертає список індексів елементів, починаючи з 1
* `get_max_element_index` - повертає індекс максимального елемента
* `get_every_second_element` - повертає список других елементів
* `get_first_three_index` - повертає індекс першої зустрічається у списку трійки
* `get_last_three_index` - повертає індекс останньої трійки, що зустрічається в списку
* `get_sum` - повертає суму елементів. Використовуйте `sum()`
* `get_min_max` - повертає `tuple` з мінімумом та максимум, якщо список не порожній, інакше дефолтне значення для мінімуму та максимуму. Використовуйте `min` та `max`
* `get_by_index` - повертає елемент за переданим індексом, якщо він більший за кордон. Інакше повертає None.
Припускаємо, індекс завжди існує.
Використовуйте оператор `:=` і спробуйте написати в один рядок за допомогою тернарного оператора. Див. мотивацію нижче.

Зверніть увагу на крайові випадки.

### Про задачу

Тут ми опрацьовуємо вибір правильної ітерації. Ми можемо ітеруватись:
* за індексами
* за значеннями
* і за індексами та за значеннями
* за допомогою for
* за допомогою while

Також використання стандартних конструкцій, коли можна написати без ітерації.

Виберіть найкращий спосіб під кожну мікрозавдання.

### Про `get_by_index`

Це невелика модельне завдання. Уявіть, що звернення за індексом працює досить довго (всередині якась функція обчислюється). Звичайний код виду
`return a[i] if a[i] > 0 else 0` бере за індексом двічі. Використовуючи "моржовий" оператор вдасться звернутися за індексом один раз і зберегти компактність запису.